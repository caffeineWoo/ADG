Organize the following content into categories and output in XML format. Page 1:Title: History of Operating Systems (cont.)Subtitle: Phase 1 — hardware is expensive, humans are cheapOne user at console- One function at a time (computation, I/O, user think/response)- Program loaded via card deck- Libraries of device drivers (for I/O)- User debugs at consoleSimple batch processing: load program, run, print results, dump, repeat- User gives program (cards or tape) to the operator, who schedules the jobs- Resident monitor automatically loads, runs, dumps user jobs- Requires memory management (relocation) and protection- More efficient use of hardware, but debugging is more difficult (from dumps)Overlapped CPU & I/O operations- First: buffer slow I/O onto fast tape drives connected to CPU, replicate I/O devices- Later: spool data to diskMultiprogrammed batch systems- Multiple jobs are on the disk, waiting to run- Multiprogramming — run several programs at the “same” time- Pick some jobs to run (scheduling), and put them in memory (memory management)Page 2:Title: History LessonsNone of these operating systems were particularly bad; each depended on tradeoffs made at that point in time- Technology changes drive OS changesSince 1953, there has been about 9 orders of magnitude of change in almost every computer system component- Unprecedented! In past 200 years, gone from horseback (10 mph) to Concorde (1000 mph), only 2 orders of magnitudeChanges in “typical” academic computer:Title: Modern OS FunctionalitySubtitle: (Review)Concurrency- Multiple processes active at once- Processes can communicate- Processes may require mutually-exclusive access to some resource- CPU scheduling, resource managementMemory management- Allocate memory to processes, move processes between disk and memoryFile system- Allocate space for storage of programs and data on diskNetworks and distributed computing- Allow computers to work togetherSecurity & protectionTitle: More Recent DevelopmentsParallel operating systems- Shared memory, shared clock- Large number of tightly-coupled processors- Appearance of single operating systemDistributed operating systems- No shared memory, no shared clock- Small number of loosely-coupled processors- Appearance of single operating system is ideal goal, but not realized in practice- May try to simulate a shared memoryReal-time operating systems- Meet hard / soft real-time constraints on processing of dataTitle: Personal computingCPUs are cheap enough to put one in each terminal, yet powerful enough to be useful- Computers for the masses!Return to simplicity; make OS simpler by getting rid of support for multiprogramming, concurrency, and protectionModern operating systems are:- Enormous- Small OS = 100K lines of code- Big OS = 10M lines- Complex (100-1000 person year of work)- Poorly understood (outlives its creators, too large for one person to comprehend)